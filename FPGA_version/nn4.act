/*
 *
 *
 *  Example with nearest-neighbor communication
 *
 *
 */
import math::fxp;

open math;

//
//  x = gridpoint
//  e = edge_in, edge_out
//
//      e    e    e    e
//      |    |    |    |
// e -- x -- x -- x -- x -- e
//      |    |    |    |
// e -- x -- x -- x -- x -- e
//      |    |    |    |
// e -- x -- x -- x -- x -- e
//      |    |    |    |
// e -- x -- x -- x -- x -- e
//      |    |    |    |
//      e    e    e    e
//

pint A = 4, B = 6;
pint TOT = A + B;
pint wi = 5, we = 30, leaky = 35;
pint threshold = 1;  // How to express 0.01 in fixed point way? (threshold = 0.01)
pint lr_act = 1;   // How to express 0.01 in fixed point way? (lr_act = 0.01)

template<pint A,B>
function softmax(int<A+B> val, threshold) : int<TOT>
{
  // assume that threshold is always > 0
 chp-txt {
   select {
   case fxp::le<A,B>(threshold,val) & fxp::positive<A,B>(val):
	self := fxp::sub<A,B>(val,threshold);
   case fxp::le<A,B>(val,fxp::uminus<A,B>(threshold)) & fxp::negative<A,B>(val):
	self := fxp::add<A,B>(val,threshold);
   else:
	self := 0
   } 
 }}

template<pint L_e; pint wE[L_e];  // excitatory weights
         pint L_i; pint wI[L_i]   // inhibitory weights
	>
defproc gridpoint (chan?(int<TOT>) init; chan!(int<TOT>) final;
		   chan?(int<TOT>) inE[L_e]; chan!(int<TOT>) outE[L_e];
		   chan?(int<TOT>) inI[L_i]; chan!(int<TOT>) outI[L_i]
		   )
{
  int<TOT> x_exc, x_inh, stim, delta_x_exc, delta_x_inh; // local value
  int i;

  int<TOT> dinE[L_e], dinI[L_i];

  // hardware description
  chp-txt {
    forever {
      // initialize iteration count to zero
      i := 0;

      // x = local value, need excitatory and inhibitory
      x_exc := 0;
      x_inh := 0;
      delta_x_exc := 0;
      delta_x_inh := 0;

      // read stimulus value
      init?stim;

      // run loop 50 times
      while (i < 50) {
	  (, j : L_e : inE[j]?dinE[j] ), (, j : L_e : outE[j]!x_exc ),
          (, j : L_i : inI[j]?dinI[j] ), (, j : L_i : outI[j]!x_inh );
	    
	// I have sent my local value out, and received values from my four neighbors
	
	// local update rule
        
        delta_x_exc := fxp::mults<A,B>(leaky, x_exc);
        delta_x_exc := fxp::uminus<A,B>(delta_x_exc);
        (; j : L_e : delta_x_exc := fxp::add<A,B>(delta_x_exc, fxp::mults<A,B>(wE[j],dinE[j])) );
        (; j : L_i : delta_x_exc := fxp::sub<A,B>(delta_x_exc, fxp::mults<A,B>(wI[j],dinI[j])) );
        delta_x_exc :=  fxp::add<A,B>(delta_x_exc, stim);
        delta_x_exc :=  fxp::mults<A, B>(lr_act, delta_x_exc);
        x_exc := fxp::add<A,B>(delta_x_exc, x_exc); 
        x_exc := softmax<A, B>(x_exc, threshold);
        
        delta_x_inh := fxp::mults<A,B>(leaky, x_inh);
        delta_x_inh := fxp::uminus<A,B>(delta_x_inh);
        (; j : L_e : delta_x_inh := fxp::add<A,B>(delta_x_inh, fxp::mults<A,B>(wE[j],dinE[j])) );
        delta_x_inh := fxp::mults<A,B>(delta_x_inh, lr_act); 
        x_inh := fxp::add<A,B>(delta_x_inh, x_inh); 
        x_inh := softmax<A, B>(x_inh, threshold);
      
        i := i + 1
      };
      final!x_exc
    }
  }
}

defproc edge_in(chan?(int<TOT>) in)
{
  int v;
  chp-txt {
     forever {
        in?v
     }
  }
}

defproc edge_out(chan!(int<TOT>) out)
{
  chp-txt {
    forever {
      out!0
    }
  }
}

function set_num_weights (pint x) : pbool;
function set_weight (pint i, dx, dy; pbool is_excite) : pbool;
function get_exc_weight (pint idx) : pint;
function get_inh_weight (pint idx) : pint;

// returns stimulus for (x,y)
function get_stim (pint x, y, batch_size ,shape) : pint;

function within_radius(pint x, y, R) : pbool
{
  chp {
    log ("compute within: ", x, ",", y, "  ", R);
    [ x*x + y*y <= R*R -> self := true
   [] else -> self := false
    ]
  }
}

function in_grid(pint i, j, N) : pbool
{
  chp {
    [ i < 0 -> self := false
   [] i >= N -> self := false
   [] j < 0 -> self := false
   [] j >= N -> self := false
   [] else -> self := true
    ]
  }
}

template<pint N, Re, Ri>
defproc grid()
{
  // compute dx, dy for neighbors
  pint Le = 0;
  (i : -Re .. Re :
    (j : -Re .. Re :
	[ (i != 0 | j != 0) & within_radius(i,j,Re) -> 
           pint dxE[Le..Le];
           pint dyE[Le..Le];
           pint wE[Le..Le];
           dxE[Le] = i;
           dyE[Le] = j;
           wE[Le] = 1;
           Le = Le + 1;
        ]
     )
  )

  // compute excitatory weights
  pbool tmp;
  tmp = set_num_weights(Le);
  (i: Le : tmp = set_weight(i,dxE[i],dyE[i],true);)
  (i: Le : wE[i] = get_exc_weight(i); 
     ${ "WeightE[", i, "]=", wE[i] };
  )
    
  pint Li = 0;
  (i : -Ri .. Ri :
    (j : -Ri .. Ri :
	[ (i != 0 | j != 0) & within_radius(i,j,Ri) -> 
           pint dxI[Li..Li];
           pint dyI[Li..Li];
           pint wI[Li..Li];
           dxI[Li] = i;
           dyI[Li] = j;
           wI[Li] = 1;
           Li = Li + 1;
        ]
     )
  )

  // compute inhibitory weights
  tmp = set_num_weights(Li);
  (i: Li : tmp = set_weight(i,dxI[i],dyI[i],false);)
  (i: Li : wI[i] = get_inh_weight(i); 
     ${ "WeightI[", i, "]=", wI[i] };
  )

  //
  // create all the components
  //
  gridpoint<Le,wE,Li,wI> a[N][N];

  // keep track of outputs that are
  // used at each grid-point
  pint ocount[N][N];
  (i : N :
    (j : N : 
        ocount[i][j] = 0;
    )
  )

  pint idx_out;

  pint ei = 0, eo = 0;

  // connect up the components in a grid pattern
  (i : N :
   (j : N :
    (l : Le :  // iterate over neighbors
      [ in_grid(i+dxE[l],j+dyE[l],N) -> 
		idx_out = ocount[ i + dxE[l] ][ j + dyE[l] ];
	        ocount[ i + dxE[l] ][ j + dyE[l] ] = idx_out + 1;
		a[i][j].inE[l] = a[i+dxE[l]][j+dyE[l]].outE[idx_out];
     [] ~in_grid(i+dxE[l],j+dyE[l],N) ->
                edge_out EO[eo..eo];
                a[i][j].inE[l] = EO[eo].out;
                eo = eo + 1;
      ]
    )
   )
  )
  // now connect unused outports to edge_in components
  (i : N :
   ( j : N :
        (l : ocount[i][j] .. Le-1 : 
              edge_in EI[ei..ei];
              a[i][j].outE[l] = EI[ei].in;
              ei = ei + 1;
        )
   )
  )


  /* 
     Connect inhibitory neighbors.
     
     This is the same as the above code that wires up excitatory
     neighbors, with Le -> Li, dxE -> dxI, dyE -> dyI, and the ports 
     inE -> inI and outE -> outI
  */
  (i : N :
    (j : N : 
        ocount[i][j] = 0;
    )
  )
  
  (i : N :
   (j : N :
    (l : Li :  // iterate over neighbors
      [ in_grid(i+dxI[l],j+dyI[l],N) -> 
		idx_out = ocount[ i + dxI[l] ][ j + dyI[l] ];
	        ocount[ i + dxI[l] ][ j + dyI[l] ] = idx_out + 1;
		a[i][j].inI[l] = a[i+dxI[l]][j+dyI[l]].outI[idx_out];
     [] ~in_grid(i+dxI[l],j+dyI[l],N) ->
                edge_out EO[eo..eo];
                a[i][j].inI[l] = EO[eo].out;
                eo = eo + 1;
      ]
    )
   )
  )
  // now connect unused outports to edge_in components
  (i : N :
   ( j : N :
        (l : ocount[i][j] .. Li-1 : 
              edge_in EI[ei..ei];
              a[i][j].outI[l] = EI[ei].in;
              ei = ei + 1;
        )
   )
  )

    //
    // ( op  i : N : stmt(i) )
    //
    // stmt(0) op stmt(1) op stmt(2) op ... op stmt(N-1)

    int v, idx;

  chp-txt {
    idx := 0;
    while (idx < 2) {
    (,i: N :
     (,j: N : a[i][j].init!get_stim (i,j, 256, 1600)
      )
     );
    //  a[0][0].init!0, a[0][1].init!1, a[0][2].init!2, a[0][3].init!3,
    //  a[1][0].init!1, a[1][1].init!2, a[1][2].init!3, etc.

    log ("--- iteration: ", idx, " ---");

    (; i : N:
     (; j : N: a[i][j].final?v; log("val @ ", i, ",", j, " := ", v)
      )
    );

    idx := idx + 1
   }
  }
}
